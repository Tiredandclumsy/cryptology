A digital signature is a method used to verify the [[CIA Triad|authenticity]] of a message.

A digital signature, assuming the sender has a key pair $(sk,pk)$ defines a signing function $\text{sign}(sk,m) = sig$,  which when sent with the public key $(sig,pk)$ allows the verifier to use the verifier function $\text{verif}(sig,pk) = m$ to confirm the identity of the sender.
While this has the same structure as [[Asymmetric enciphering scheme|asymmetric encryption]], the important behaviour is the inability to compute $sig$ or $pk$ given $pk$ and $m$.

# ElGamal Signatures
One way of achieving digital signature is with ElGamal Signatures. The procedure, assuming $A$ signing a message from $B$, is as follows:
Setup:
- $A$ chooses a prime $p$ and generating element $g \in (\Bbb Z /p \mathbb Z)^*$
- $A$ generates a key pair (usually by [[Diffie-Hellman Key Exchange]]) $(sk,pk) = (a,g^a \pmod p)$ where $a \in [0,p-1]$, and publishes $pk$
- $B$ gives the message $m \pmod{p-1}$ to be signed
Signing
- $A$ picks a random [[Nonce-Based Encryption|nonce]] $k \in [0,p-1]$ coprime to $p-1$
- $A$ computes $r = g^k \pmod p$
- $A$ computes the signature $sig = k^{-1} (m-ar) \pmod{p-1}$
- $A$ publishes the signed message $(r,sig)$
Verification
- $B$ checks that $g^m = pk ^r \times r^{sig} \pmod p$
## Analysis
The verification step can be proven to work by noting $pk^r \times r^{sig} = (g^a)^r \times (g^k)^{k^{-1}(m-ar)} = g^m$
The use of $p-1$ as the modulus instead of $p$ is due to the appearance of $m$ in the exponent. 
Note all values save $a$ and $k$ are public, so if the attacker knows the nonce they can recover the secret key by rearranging the definition of the signature.
Also note that if the nonce is used more than once, $sig_1 = k^{-1}(m_1-ar) \pmod{p-1}, sig_2=k^{-1}(m_2 -ar) \pmod{p-1}$ $k = \cfrac{m_1 - m_2}{sig_1 - sig_2} \pmod{p-1}$

# RSA signatures
Another method of digital signature is RSA signatures. Again assuming $A$ signing a message from $B$, the procedure is as follows:
Setup
- $A$ generates an [[RSA]] key pair $(sk,pk) = ((d,n),(e,n))$ and publishes $(e,n)$
- $B$ gives $A$ a message $m \pmod n$ to be singed
Signing
- $A$ computes $sig = m^d \pmod n$
- $A$ sends $(sig, (e,n))$ to $B$
Verification
- $B$ checks that $m = sig ^e \pmod n$
## Analysis
The scheme is consistent by [[Fermat's Little Theorem]]:
$sig ^e = (m^d)^e = m^{de} = m^{1 + k \varphi(n)} = m \times (m^{\varphi(n)})^k = m \pmod n$
The only way to send a message signed by the public key $(e,n)$ is to know $(d,n)$, generated by RSA, and so the signature is as secure as RSA.

 
#cryptology 